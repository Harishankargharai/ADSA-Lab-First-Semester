// This is the ternary search implementation 

#include <stdio.h>

int ternarySearch(int arr[], int low, int high, int key) {
    while (low <= high) {
        int mid1 = low + (high - low) / 3;
        int mid2 = high - (high - low) / 3;

        if (arr[mid1] == key) return mid1;
        if (arr[mid2] == key) return mid2;

        if (key < arr[mid1]) {
            high = mid1 - 1;
        } else if (key > arr[mid2]) {
            low = mid2 + 1;
        } else {
            low = mid1 + 1;
            high = mid2 - 1;
        }
    }
    return -1; // Not found
}

int main() {
    int arr[] = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20};
    int n = sizeof(arr) / sizeof(arr[0]);
    int key = 14;

    int index = ternarySearch(arr, 0, n - 1, key);
    if (index != -1)
        printf("Element found at index %d\n", index);
    else
        printf("Element not found\n");

    return 0;
}

// This is the binary search implementation

int binarySearch(int arr[], int low, int high, int key) {
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == key) return mid;
        if (key < arr[mid]) high = mid - 1;
        else low = mid + 1;
    }
    return -1;
}

// Comparison on Large value of n

#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int binarySearch(int arr[], int low, int high, int key) {
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == key) return mid;
        if (key < arr[mid]) high = mid - 1;
        else low = mid + 1;
    }
    return -1;
}

int ternarySearch(int arr[], int low, int high, int key) {
    while (low <= high) {
        int mid1 = low + (high - low) / 3;
        int mid2 = high - (high - low) / 3;

        if (arr[mid1] == key) return mid1;
        if (arr[mid2] == key) return mid2;

        if (key < arr[mid1]) {
            high = mid1 - 1;
        } else if (key > arr[mid2]) {
            low = mid2 + 1;
        } else {
            low = mid1 + 1;
            high = mid2 - 1;
        }
    }
    return -1;
}

int main() {
    int n = 1000000; // 1 million elements
    int *arr = malloc(n * sizeof(int));
    for (int i = 0; i < n; i++) arr[i] = i;

    int key = n - 1; // worst case
    int iterations = 100000; // repeat for averaging

    clock_t start, end;

    // Test binary search
    start = clock();
    for (int i = 0; i < iterations; i++) {
        binarySearch(arr, 0, n - 1, key);
    }
    end = clock();
    double timeBinary = ((double)(end - start)) / CLOCKS_PER_SEC;

    // Test ternary search
    start = clock();
    for (int i = 0; i < iterations; i++) {
        ternarySearch(arr, 0, n - 1, key);
    }
    end = clock();
    double timeTernary = ((double)(end - start)) / CLOCKS_PER_SEC;

    printf("Binary Search Time: %.6f sec\n", timeBinary);
    printf("Ternary Search Time: %.6f sec\n", timeTernary);

    free(arr);
    return 0;
}

// Binary Search is slightly faster because fewer comparisons per step, even though ternary search makes fewer recursive calls
